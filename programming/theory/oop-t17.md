# Обектно-ориентирано програмиране. Подтипов и параметричен полиморфизъм. Множествено наследяване

Полиморфизъм - едно име, но много различни имплементации 
Статично свързване - изборът на функция става по време на компилация(function overloading)
Динамично свързване - изборът на функция става по време на изпълнение(function overloading)

Динамично свързване - изборът на функция става по време на изпълнение 

```cpp
struct Base {
    void f() const { 
        std::cout << 1;
    }
    virtual void g() const {
        std::cout << 2;
    }
};

struct Der {
    void f() const { 
        std::cout << 2;
    }
    virtual void g() const {
        std::cout << 2;
    }
};

Der d;
f(d); // 1(от f) 2(от g)
```


1. Виртуални функции и подтипов полиморфизъм. Динамично свързване.
Абстрактни методи и класове. Масиви от обекти и от указатели към обекти.

- overrides keyword

```cpp
struct X {
    virtual void f() = 0;
};
```
абстрактен метод - метод, който трябва да се презашище от всеки неабстрактен метод 
абстрактен клас - клас, който има поне един абстрактен метод или не презаписва някой абстрактен метод от базов клас 


Хетерогенен контейнер - контейнер от указатели към базовия клас 


```cpp 

Container {
    Base** data;
}


// триене
for(int i = 0; i < size; ++i) {
    delete[] data[i];
}
// за да работи коректно триенето, трябва декструктора в базовия клас да бъде виртуален

// копиране - чрез prototype design pattern
// чисто виртуална функция clone в базовия клас
// имплементира се от всеки от наследниците

data = new Base*[other.size];
for(int i = 0; i < other.size; ++i) {
    data[i] = other.data[i] -> clone();
}


```

Работим абстрактно, без да се интересуваме какъв тип са обектите!!! 


2. Параметричен полиморфизъм. Шаблони на функция и на клас
Една и съща имплементация не зависи от типовете. 
```cpp
// пример за шаблонна функция 

template<class T>
const T& max(const T& lhs, const T& rhs) {
    return rhs > ths ? lhs : rhs;
}

// можем да създаваме и шаблонни класове 


template<class T>
class Vector {
    T* data;
    std::size_t cap;
    std::size_t size; 
}

// шаблонна специализация - клас/функция, която се дъжи различно за определени типове 
Напр. std::vector<bool> - битсет(memory efficient)

```

Компилаторът създава код за всеки тип, с който е извикана функцията. Трябва да сме сигурни, че във функцията се ползват само позволени за конкретния тип операции.  


3. Множествено наследяване.

Един клас може да има повече от един базов клас.

X: virtual Y -> Всеки наследник на X е отговорен за извикването на конструктор на Y.