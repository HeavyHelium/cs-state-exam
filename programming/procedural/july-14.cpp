#include <iostream>


/*
Дадена е квадратна матрица от цели числа с размери 10x10, която описва лабиринт. Стойност 0 в
дадена клетка означава „стена“, а стойност 1 означа „проходима клетка“. Даден е символен низ,
съдържащ само буквите E, W, N и S, които указват едностъпкови придвижвания в съответните
географски посоки: N – нагоре, E – надясно, S – надолу, W – наляво.
Да се напише функция walk, която получава матрица и символен низ от вида, определен по-горе и
проверява дали символният низ задава валиден път започващ от някоя проходима клетка на
лабиринта, състоящ се само от проходими клетки и завършващ в долния десен ъгъл на лабиринта.
Функцията да връща булева стойност – истина, ако такава клетка има и даденият низ задава
валиден път и лъжа в противен случай.
 */

struct point {
    int x = 0;
    int y = 0;
};

point dir(char letter) {
    switch(letter) {
        case 'E': return point{0, 1};
        case 'W': return point{0, -1};
        case 'N': return point{-1, 0};
        case 'S': return point{1, 0};
        default: return {};
    }
}

bool walk(int maze[][10], const char* path, point curr) {
    if(!*path && curr.x == 9 && curr.y == 9) return true;
    if(!*path) return false;

    char letter = *path;
    path += 1;
    point d = dir(letter);
    if(d.x == 0 && d.y == 0) return false;

    point temp = { curr.x + d.x, curr.y + d.y };

    if(temp.x < 0 || temp.x >=10 || 
       temp.y < 0 || temp.y >= 10 || 
       maze[temp.x][temp.y] != 1) {
        return false;
    }

    return walk(maze, path, temp);

}


void testWalk(int maze[][10], const char* path) {
    bool result = walk(maze, path, point{0, 0});
    std::cout << "Maze:\n";
    for(int i = 0; i < 10; ++i) {
        for(int j = 0; j < 10; ++j) {
            std::cout << maze[i][j] << " ";
        }
        std::cout << "\n";
    }
    std::cout << "Path: " << path << "\n";
    std::cout << "Result: " << (result ? "Valid" : "Invalid") << "\n\n";
}

int main() {
    // Test case 1: Simple path with blocked rows below
    int maze1[10][10] = {
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    };
    testWalk(maze1, "EEEEEEEEEEEEEEEEEEEE");

    // Test case 2: Correct path from top-left to bottom-right
    int maze2[10][10] = {
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},
        {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
        {1, 0, 1, 0, 0, 0, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 0, 0, 0, 1, 0, 1},
        {1, 0, 1, 1, 1, 1, 0, 1, 0, 1},
        {1, 0, 0, 0, 0, 0, 0, 1, 1, 1}
    };
    testWalk(maze2, "EEESSEEEESSSSSSSEE");

    // Test case 3: No valid path
    int maze3[10][10] = {
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    testWalk(maze3, "SSSSSSSSSEE");

    // Test case 4: Maze surrounded by walls
    int maze4[10][10] = {
        {1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    };
    testWalk(maze4, "EEEEEEEEEEEE");

    // Test case 5: Path blocked by wall
    int maze5[10][10] = {
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0}
    };
    testWalk(maze5, "EEEEEEEEEEEE");

    // Test case 6: Edge case with single move
    int maze6[10][10] = {
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
    };
    testWalk(maze6, "SE");

    return 0;
}