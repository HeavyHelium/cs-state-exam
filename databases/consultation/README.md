# Консултация

## Задачи

- очакваме select, като може да има insert, update, delete, но логиката за select е достатъчно

- ние пишем заявка
- ние избираме коя заявка е вярна

Важно е да знаем как всеки един от вариантите може да бъде валиден

- is NULL -- честа грешка, ако ползваме =, ще се получи UNKNOWN

- преименуване при join на таблица със себе си

* трябва да внимаваме, когато не искаме повторения -- distinct

* select се изпълнява най-накрая;

❗ Трябва да внимаваме с реда на изпълнение на клаузите

### Подзаявки

- първо се изпълнява най-вътрешната подзаявка

Задача, при която трябва да се внимава(not in, вземаме допълнение):  
● Класовете, на които нито един от
корабите им не е потънал в битка
– Има кораби, които не са участвали в битки
– Има дори класове без кораби

- на подзаявката винаги трябва да й сложим име(но по-скоро няма да го има, синтактична особеност)

#### Корелативни подзаяки

```sql
SELECT DISTINCT title
FROM Movie M
WHERE year < ANY (SELECT year
 FROM Movie
 WHERE title = M.title);

```

екв.

```c#
foreach(Movie M: movie) {
    if (M.year < getYears(M)) {
        results.push(M);
    }
}

```

### Joins

- да внимаваме с реда на join-овете(ако имаме поне един puter join трябва да внимаваме)
  - често пъти е по-коректно да правим първо inner join преди left/right join
  * понякога е по-добре да правим агрегация

### Агрегация и групиране

#### Агреграция

- винаги връщат един ред

* агрегатната функция отпред - грешка

```sql

SELECT *
FROM movie
WHERE length = MAX(SELECT length
 FROM movie);
```

#### Незадъжителен материал

- case

## Теория
